#!/usr/bin/python
# -*- coding:utf-8 -*-
"""how to use : after having imported the works into calibre AND imported the custom columns, run this script to populate the custom columns with the AO3 tags and data
what it does : for a calibre book folder, created from an AO3 .epub file, parse the metadata in the beginning of the work toward calibre readable metadata in the metadata database"""

import os, zipfile, re, codecs,sys
from bs4 import BeautifulSoup
import sqlite3
from HTMLParser import HTMLParser


import_directory="calibre_library"

use_fimfiction=True
if use_fimfiction:
	import json
	fimfiction_metadata_file="fimfiction_tags.json" #if you only have work from AO3 this is irrelevant. path to the json that was generated by download_epub.py containing the metadata extracted from the webpage of fimfiction works

only_process_new=True #only tag works that seem new. False to re-tag work. this works by checking if the fandom is set

#here's a list of possible columns : tags, series_ao3, word_count, content_rating, read, status, category_relationships, fandom, genre, relationships, characters
columns_to_update=["tags","series_ao3","word_count","content_rating","status","category_relationships","fandom","genre","relationships","characters","ao3_tags"] #add here all columns you want the script to update. "read" should be in this list but I removed it because reasons =(
#columns_to_update=["tags"] #add here all columns you want the script to update

custom_tags=True #Wether you want to add my custom tags. True to add the tags, False to only keep the original tags. this goes to the native "tags" column of calibre
custom_tags_list=["threesome"] #list of my tags
transfer_tags_list={} #list of AO3 tags to copy to calibre native tags
transfer_tags_list["Hogwarts Eighth Year"]="HP.8th year"
transfer_tags_list["Post-Canon"]="post-canon"
transfer_tags_list["Alpha/Beta/Omega Dynamics"]="ABO"

short_fandom={} #each character name is formatted as fandom.character, for example Avatar : The Last Airbender.Zuko This might be too verbose to your liking. Use this dictionnary to define a short name for a fandom. For example if you define short_fandom["Avatar : The Last Airbender"]="ATLA" Zuko will be named "ATLA.Zuko". No correction is performed on the long name, so be careful to type it exactly as it is. This dictionnary can also be used to put different things under the same name, for example the several "fullmetal alchemist" fandoms
short_fandom["Avatar: The Last Airbender"]="ATLA"
short_fandom["Avatar: Legend of Korra"]="LoK"
short_fandom["Fullmetal Alchemist"]="FMA"
short_fandom["Fullmetal Alchemist - All Media Types"]="FMA"
short_fandom["Fullmetal Alchemist (Anime 2003)"]="FMA"
short_fandom["Fullmetal Alchemist: Brotherhood & Manga"]="FMA"
short_fandom["Harry Potter - Rowling"]="HP"
short_fandom["Harry Potter - J. K. Rowling"]="HP"
short_fandom["Subarashiki Kono Sekai | The World Ends With You"]="TWEWY"
short_fandom["Tales of Symphonia"]="ToS"
short_fandom["Yuri!!! on Ice (Anime)"]="YoI"
short_fandom["Tsubasa: Reservoir Chronicle"]="Tsubasa"
shorten_fandom_itself=True #use the short name defined above for the metadata "fandom" itself

short_ship={} #use a shorten version of a character name in the relationship metadata. For example "HP.Draco Malfoy/Harry Potter" becomes "HP.Draco/Harry" or even "HP.Drarry". Enter only the name of the ship, without the fandom in front, like "Draco/Harry". This has no effect on the "character" metadata
short_ship["Draco Malfoy/Harry Potter"]="Draco/Harry"
short_ship["Sirius Black/Remus Lupin"]="Wolfstar"
short_ship["Christophe Giacometti/Katsuki Yuuri/Victor Nikiforov"]="Chris/Yuuri/Victor"

short_character={} #same as previously, but with only one character. For example if you have one character in ships with several other characters, you can add his name here to be shortened in all of his ships. Enter only the name of the character without the fandom, for example "Draco Malfoy" This has no effect on the "character" metadata
short_character["Christophe Giacometti"]="Chris"
short_character["Katsuki Yuuri"]="Yuuri"
short_character["Yuuri Katsuki"]="Yuuri"
short_character["Yuri Katsuki"]="Yuuri"
short_character["Victor Nikiforov"]="Victor"
short_character['Bito "Beat" Daisukenojou']="Beat"
short_character['Bito "Rhyme" Raimu']="Rhyme"
short_character['Kiryu "Joshua" Yoshiya']="Joshua"


test_file="/home/ezi/Dropbox/save/lecture - fics/calibre_library/dance_across/After Everyone Else (2)/After Everyone Else - dance_across.epub"
#test_file="/home/ezi/Dropbox/save/lecture - fics/calibre_library/Sy_Itha/Conflict Resolution (15)/Conflict Resolution - Sy_Itha.epub"

global_genre="fiction.fanfiction" #I like to put all my fanfiction in this sub-genre. you can change the value at will
global_read_status="New" #All imported fics read status. you can set this to "New" "On it" or "Read" . mind the capital.

hierarchical_columns=["characters","relationships"] #characters and relationships can be hierarchical or not. don't add any other.


db=sqlite3.connect("calibre_library/metadata.db")
cursor=db.cursor()

#do not touch
custom_columns={}
custom_columns["word_count"]="1"
custom_columns["genre"]="2"
custom_columns["characters"]="3"
custom_columns["fandom"]="4"
custom_columns["relationships"]="5"
custom_columns["status"]="6"
custom_columns["read"]="7"
custom_columns["content_rating"]="8"
custom_columns["category_relationships"]="10"
custom_columns["series_ao3"]="12"
custom_columns["ao3_tags"]="13"
custom_columns["tags"]="tags" #put the non-custom columns in here, with data same as the key
#custom_columns["series"]="series"

rating_conversion={}
rating_conversion["Explicit"]="E"
rating_conversion["Mature"]="M"
rating_conversion["Teen And Up Audiences"]="T"
rating_conversion["General Audiences"]="G"
rating_conversion["Not Rated"]=""



def format_relationship(ship):
	"""for a relationship name, puts the characters in alphabetical order, format/shorten the name of the characters (capitalisation etc) or the relationship if necessary (like wolfstar)"""
	#avoid duplicates due to different order
	#assumes that 3+ relationships have all the same separator (& or /)

	ship=re.sub(" - Relationship","",ship)
	separator=""
	if re.search("/",ship):
		separator="/"
	elif re.search("&",ship):
		separator="&"
	if separator:
		names=re.split("[/&]",ship)
		ship=[]
		for name in names:
			name=name.strip()
			name=format_character_name(name)
			if name in short_character:
				name=short_character[name]
			ship.append(name)
		ship.sort()
		ship=separator.join(ship)
	else:
		#weird formatting, do nothing
		pass
	if ship in short_ship:
		ship=short_ship[ship]
	return ship

def format_character_name(name):
	""" on a character name, corrects capitalisation and deletes parenthesis content"""
	name=re.sub("\(.*?\)","",name) #delete parenthesis content, such as "Draco Malfoy (Harry Potter)"
	name=re.split("( )",name) #split on space, keep the spaces
	#correct capitalisation
	for i,a in enumerate(name):
		if a !="'s":
			if len(a)>1:
				name[i]=a[0].upper()+a[1:]
			else:
				name[i]=a.upper()
	name="".join(name)
	name=name.strip()
	return name

def build_work_list(directory):
	"""recursively finds the location of all epub files in a directory"""
	list_=[]
	for root, dirs, files in os.walk(directory, topdown=False):
		for fname in files:
			if fname.endswith(".epub"):
				list_.append( os.path.join(root,fname) )
	return list_

def parse_ao3_metadata(epub_file,fimfictiondata=False):
	"""read and parse metadata from the AO3 header and return a dictionary of found values
	epub_file argument must be the path+name of a .epub file inside the calibre directory. not the original .epub file
	fimfictiondata is only used if you have fimfiction epub files. this contains the metadata in the form of a dictionary where the key is title+author of a work"""
	
	metadata={}
	metadata["genre"]=global_genre
	metadata["read"]=global_read_status
	source_site=""



	with zipfile.ZipFile(epub_file) as z:
		try:
			with z.open("OEBPS/preface.xhtml") as f :
				source_site="ao3"
				html=f.readlines()
				html="\n".join(html)
				soup=BeautifulSoup(html,"lxml")

				#work ID
				uri=soup.findAll("a")[1]["href"]
				uri=re.sub("download\.","",uri)

				#metadata
				informations = soup.findAll("div", { "class" : "meta" })[0]
				info_text=informations.getText()
		except KeyError:

			try :
				with z.open("title.html") as f :
					source_site="fimfiction"
					html_parser=HTMLParser()
					for l in f:
						if re.search("h1",l):
							title=re.findall(">(.*?)<",l)[0]
							title=title.strip()
							title=html_parser.unescape(title)
						if re.search("Written by",l):
							author=re.sub("</a>.*$","",l)
							author=re.sub('^.*">','',author)
							author=author.strip()
							author=html_parser.unescape(author)
							fimfiction_id=title+"+"+author
							break
				with z.open("book.opf") as f:
					for l in f:
						if re.search("dc:identifier",l):
							uri=re.findall('URI">(.*?)<',l)[0]
							break

			except KeyError:
				return False #not an AO3 file nor a fimfiction file



		if source_site=="ao3":

			#parsing of the metadata in the html
			#variable "info_text" contains the relevant part of the html in a string
			raw_data={}
			for data in ["Rating"]:
				try :
					raw_data[data]=re.findall(data+":\n(.*?)\n",info_text)[0]
				except IndexError:
					raw_data[data]=""
			for data in ["Fandom","Character","Relationship","Category","Additional Tags"]:
				try :
					s=re.findall(data+":\n(.*?)\n",info_text)[0]
					s=s.split(",")
					s=[x.strip() for x in s]
					raw_data[data]=s
				except IndexError:
					raw_data[data]=""

			word_count=re.findall("Words: (\d+)",info_text)[0]
			try:
				chapters=re.findall("Chapters: (.*?)\n",info_text)[0]
			except IndexError:
				chapters="1/1"

			series_match=re.findall("Series:\nPart (\d+) of\n\n(.*?)\n",info_text)
			if series_match:
				raw_data["series_n"],raw_data["series"]=series_match[0]
			else:
				raw_data["series"]=False #name of the series
				raw_data["series_n"]=False #number of the work in the series


			#formatting
			#metadata is a dictionary containing the final, clean values of all found metadata, and will be returned at the end
			metadata["content_rating"]=rating_conversion[raw_data["Rating"]]
			
			metadata["category_relationships"]=raw_data["Category"]
			metadata["word_count"]=word_count
			if raw_data["series"]:
				metadata["series_ao3"]=re.sub("[\.,']"," ",raw_data["series"])
				#I made this when I tried to use calibre native "series" metadata, that didn't work like the others. could probably delete this now.
			else:
				metadata["series_ao3"]=False
			metadata["series_number"]=raw_data["series_n"]


			if shorten_fandom_itself:
				metadata["fandom"]=[]
				for item in raw_data["Fandom"]:
					if item in short_fandom:
						metadata["fandom"].append(short_fandom[item])
					else:
						metadata["fandom"].append(item)
			else:
				metadata["fandom"]=raw_data["Fandom"]

			metadata["tags"]=[]
			for column_name,column_list in {"characters": raw_data["Character"], "relationships":raw_data["Relationship"],"ao3_tags":raw_data["Additional Tags"]}.iteritems():

				#column_name = "characters", "relationships"...
				#column_list = ["harry potter","draco malfoy"] ...
					
				formatted_list=[]
				for item in column_list:
					item=item.strip()
					if column_name == "characters":
						item=format_character_name(item)

					elif column_name =="relationships":
						item=format_relationship(item)
						if len(re.findall("/",item))>1 and "threesome" in custom_tags_list:
							metadata["tags"].append("threesome")
							#TODO missing an option to not do this
						

					if column_name in hierarchical_columns:
						fd=metadata["fandom"][0] #TODO hack, if there is several fandoms, just associate the characters with the first fandom
						if fd in short_fandom:
							fd=short_fandom[fd]
						fd=re.sub("\."," ",fd) #to avoid bugs with the hierarchical structure
						item=re.sub("\."," ",item)
						item=fd+"."+item
					formatted_list.append(item)
				metadata[column_name]=formatted_list

			for tag in metadata["ao3_tags"]:
				if tag in transfer_tags_list:
					metadata["tags"].append(transfer_tags_list[tag])


			
			chapters=chapters.strip()
			chapters=chapters.split("/")
			if chapters[1]=="?" or chapters[1]!=chapters[0]:
				metadata["status"]="Ongoing"
			else:
				metadata["status"]="Complete"


		elif source_site=="fimfiction":
			#most of the metadata are not in the epub and should have been extracted from the webpage by download_epub.py we get back those from the json file it generated
			try :
				data=fimfictiondata[fimfiction_id]
			except TypeError:
				sys.stderr.write("error : tried to process a fimfiction file but the metadata json file was not provided\n")
			metadata["fandom"]="MLP" #TODO make an option to choose that
			for info in data:
				if info=="tags":
					metadata["ao3_tags"]=data["tags"]
				elif info=="characters":
					metadata["characters"]=[]
					for character in data["characters"]:
						character="MLP."+character
						metadata["characters"].append(character)
				elif info in ["content_rating","word_count"]:
					metadata[info]=data[info]
				else:
					print "warning, a fimfiction metadata was in no known format :",info
				
	
	return uri,metadata


def fetch_value_id(table_name,value_real,create_missing=False,):
	"""returns the id of a value for a custom column. with option create_missing, creates the value if it doesn't exist already ; otherwise, raise an error"""

	value_column_name="value" #name of the column where we want to find value_real
	if table_name in ["tags"]:
		value_column_name="name" #histoire de faire chier


	#print "rfffffff",[table_name,value_column_name,value_real]
	cursor.execute("SELECT id FROM "+table_name+" WHERE "+value_column_name+"= ?", (value_real,))
	rows= cursor.fetchone()
	if rows:
		value_id=str(rows[0])
	else:
		if create_missing:
			max_id=cursor.execute("SELECT MAX(id) FROM "+table_name)
			max_id=cursor.fetchone()[0]
			if max_id:
				value_id=max_id+1
			else:
				value_id=1
			#print "eeeee",[table_name,value_column_name,value_id,value_real]
			cursor.execute("INSERT INTO "+table_name+" (id, '"+value_column_name+"') VALUES (?,?)" , (value_id,value_real) )
		else:
			sys.stderr.write("error : the value "+value_real+" doesn't exist for the column "+table_name+". be sure to enter EXACTLY an existing value\n")
			raise ValueError
	return str(value_id)



def edit_calibre_database(uri,metadata):
	"""edit the metadata database of calibre
	uri must be the url of the work on AO3. like "http://archiveofourown.org/works/9290123"
	metadata must be a dictionnary produced by parse_ao3_metadata()
	"""

	#find the book id
	cursor.execute("SELECT book,val FROM identifiers WHERE val='"+uri+"'")
	rows=cursor.fetchone()
	if rows:
		id_=str(rows[0])
	else:
		#can't find uri in calibre db, try switching http / https
		if uri[4]=="s":
			uri=uri[:4]+uri[5:]
		else:
			uri=uri[:4]+"s"+uri[4:]

		cursor.execute("SELECT book,val FROM identifiers WHERE val='"+uri+"'")
		rows=cursor.fetchone()
		if rows:
			id_=str(rows[0])
		else:
			#really can't find uri
			sys.stderr.write("error : uri "+uri+" not found. have you first imported the work into calibre ?\n")
			return 0

	#print "id:",id_

	#check if fandom is already set, to know if this is a new book
	if only_process_new:
		cursor.execute("SELECT * from books_custom_column_"+custom_columns["fandom"]+"_link WHERE book="+id_) 
		if cursor.fetchone():
			#print "Skipped this work (already tagged)"
			return
	

	print "processing ",uri


	for metadata_type in columns_to_update:
		try:
			value_real_list=metadata[metadata_type] #the real, textual values of the metadata
		except KeyError :
			continue #no value set for this metadata
		column_number=custom_columns[metadata_type] #identifier of the type of metadata

		#determine table name
		column_name="custom_column_"+column_number
		if metadata_type=="tags":
			column_name="tags"
		column_name_link="books_"+column_name+"_link"
		if metadata_type=="word_count":
			column_name_link=column_name

		#determine the name of the column where the real values are in the table custom_column_N or tags
		value_column_name="value"
		if column_name=="tags":
			value_column_name="tag"


		create_missing=True
		if metadata_type in ["genre","status","read","content_rating"]:
			#create_missing=False #those have a fixed number of possible values. will return an error if we ask for a value that doesn't exist TODO remove that safeguard at the end for usability
			pass


		#fetch value id
		is_list=True
		if type(value_real_list)!=list:
			value_real_list=[value_real_list]
			is_list=False

		for value_real in value_real_list:

			if not value_real:
				continue

			if metadata_type=="word_count":
				value_id=value_real
			else:
				#print "ezrjoerzeeeee",column_name,value_real
				value_id=fetch_value_id(column_name,value_real,create_missing)


			#update the database

			if is_list :
			#if the metadata is list-like (tag-like) we don't want to replace an existing value, we want to add a new row
				#check if the specific pair of book and value already exist, create it if not
				cursor.execute("SELECT * FROM "+column_name_link+" WHERE book='"+id_+"' and "+value_column_name+"='"+value_id+"'")
				row=cursor.fetchone()
				if not row:
					cursor.execute("INSERT INTO "+column_name_link+" (book,"+value_column_name+") VALUES(?,?)",(id_,value_id))
				else:
					pass #the information is already in the db, do nothing

			else:
				#check if there is already a value for that work and metadata in the db
				cursor.execute("SELECT * FROM "+column_name_link+" WHERE book="+id_)
				rows=cursor.fetchall()

				if rows:
					#update
					if metadata_type=="series_ao3":
						cursor.execute("UPDATE "+column_name_link+" SET value = "+value_id+" , extra = "+metadata["series_number"]+" WHERE book ="+id_ )
					else:
						cursor.execute("UPDATE "+column_name_link+" SET "+value_column_name+" ="+value_id+" WHERE book ="+id_)
				else:
					#insert
					if metadata_type=="series_ao3":
						cursor.execute("INSERT INTO "+column_name_link+" (book,value,extra) VALUES(?,?,?)",(id_,value_id,metadata["series_number"]))
					else:
						cursor.execute("INSERT INTO "+column_name_link+" (book,"+value_column_name+") VALUES(?,?)",(id_,value_id))


	db.commit()


if __name__=="__main__":
	works=build_work_list(import_directory)

	#formats the ship names provided by the user in order to match the formatting of ships extracted from the epub
	short_ship2={}
	for ship in short_ship:
		ship2=format_relationship(ship)
		short_ship2[ship2]=short_ship[ship]
	short_ship=short_ship2

	if use_fimfiction:
		with open(fimfiction_metadata_file,"r") as jsonf:
			fimfiction_data=json.load(jsonf)
	else:
		fimfiction_data=False

	for work in works:
		data=parse_ao3_metadata(work,fimfiction_data)
		if data:
			edit_calibre_database(data[0],data[1]) #may return 0 if there was an error




